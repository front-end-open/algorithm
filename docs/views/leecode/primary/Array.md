# 数组

> 数组正可谓一个经典的数据结构，无论是在算法还是在编程的数据类型中，都是一个典型的存在。编程语言中，作为数据类型；在数据结构中，可以作为栈和队列的描述。亦可作为线性表的的线性存储结构描述。

## 基础算法练习

1. 数据去重
2. 数组集合运算

## 习题

1. 存在重复元素
   > 给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

示例 1:

```js
输入: [1, 2, 3, 1];
输出: true;
```

示例 2:

```js
输入: [1, 2, 3, 4];
输出: false;
```

示例 3:

```js
输入: [1, 1, 1, 3, 3, 4, 3, 2, 4, 2];
输出: true;
```

解答:

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */

// 对于数值的数组集合判重，直接经过排序后，进行比较即可
// 因为排序后，如果存在相同元素，必定是相邻的。
var containsDuplicate = function (nums) {
  nums.sort();

  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i] == nums[i + 1]) {
      return true;
    }
  }
  return false;
};
```

2. 只出现一次的数字
   > 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

要求:

- 线性复杂度(O(n))
- 不能使用额外数组空间

示例 1:

```js
输入: [2, 2, 1];
输出: 1;
```

示例 2:

```js
输入: [4, 1, 2, 1, 2];
输出: 4;
```

解答

```java
   public int singleNumber(int nums[]) {
    int result = 0;
    for (int i = 0; i < nums.length; i++){
         result ^= nums[i];
    }
    return result;
   }
```

3. 两个数组的交集
   > 给定两个数组，编写一个函数来计算它们的交集。

示范 1:

```js
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

```

示范 2:

```js
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

说明:

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

进阶：

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果  nums1  的大小比  nums2  小很多，哪种方法更优？
- 如果  nums2  的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

分析:

1. 两个数组交替出现的元素，以最小出现次数为准？

解答：

```js

```

4. 加一
   > 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
   > 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
   > s 你可以假设除了整数 0 之外，这个整数不会以零开头。

示范 1:

```js
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

示范 2:

```js
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

示范 3:

```js
输入：digits = [0]
输出：[1]
```

提示:

- 1 <= digits.length <= 100
- 0 <= digits[i] <= 9

分析:

1...

2...

解答:

```js
...
```

5.移动 零

> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
> 示范:

```js
输入: [0, 1, 0, 3, 12];
输出: [1, 3, 12, 0, 0];
```

说明:

- 必须在原数组上操作，不能拷贝额外的数组。
- 尽量减少操作次数。

考察点: _双指针_, _数组_

分析:
1...
2...

解答:

```js
.....
```

6. 两数之和

   > 给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那   两个   整数，并返回它们的数组下标。
   > 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
   > 你可以按任意顺序返回答案。

   示范 1:

   ```js
   输入：nums = [2,7,11,15], target = 9
   输出：[0,1]
   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
   ```

   示范 2:

   ```js
   输入：nums = [3,2,4], target = 6
   输出：[1,2]
   ```

   示范 3:

   ```js
   输入：nums = [3,3], target = 6
   输出：[0,1]
   ```

   提示:

提示：

- 2 <= nums.length <= 104
- 109 <= nums[i] <= 109
- 109 <= target <= 109
- 只会存在一个有效答案

分析:

1..

2..

解答:

```js
....
```

8. 有效的数独

   > 请你判断一个  9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
   > 数字  1-9  在每一行只能出现一次。
   > 数字  1-9  在每一列只能出现一次。
   > 数字  1-9  在每一个以粗实线分隔的  3x3  宫内只能出现一次。（请参考示例图）
   > 数独部分空格内已填入了数字，空白格用  '.'  表示。

注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可

示范 1:

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png">

```js
输入：board =
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

示范 2:

```js
输入：board =
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

提示:

- board.length == 9
- board[i].length == 9
- board[i][j] 是一位数字或者 '.'

分析:

1...

2...

考点: _数组_, _哈希表_, _矩阵_

解答:

```js
....
```

9. 旋转图像

   > 给定一个 n × n 的二维矩阵  matrix 表示一个图像。请你将图像顺时针旋转 90 度。
   > 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

   示范 1：

   <img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg">

```js
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

示范 2:

```js

输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

示范 3:

```js
输入：matrix = [[1]]
输出：[[1]]
```

示范 4:

```js
输入：matrix = [[1,2],[3,4]]
输出：[[3,1],[4,2]]
```

提示:

- matrix.length == n
- matrix[i].length == n
- 1 <= n <= 20
- -1000 <= matrix[i][j] <= 1000

考察点: _数学_，_矩阵_，_数组_

解答:

分析:

1..

2..

```js
....
```
