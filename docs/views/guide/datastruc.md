---
sidebar: "auto"
---

# 数据结构

## 布局

- 流式布局
  1. 宽度自适应，高度写死，并不是百分百还原设计图。
  2. 图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。
  3. 一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化,对于小图标或者文本等, 一般都是定死宽高大小。

​ 布局方案:

​ 1. 左侧固定，右侧自适应

​ 2. 右侧固定，左侧自适应

​ 3. 两侧固定，中间自适应(圣杯布局，双飞翼布局)

​ 4. 等分布局

实现:

```css
<style>
    * {
      margin: 0;
      padding: 0;
    }
    .father {
      height: 400px;
      background-color: pink;
    }
    .left {
      height: 300px;
      width: 200px;
      background-color: orange;
      float: left;
    }
    .right {
      height: 350px;
      background-color: blue;
      /* 触发了bfc的盒子, 不与浮动的元素重叠 */
      overflow: hidden;
    }
</style>

```

### 视口(Viewport)：

> 移动端，视口不完全等于浏览器可视区域，现在浏览器默认将浏览器视口设置为 980px，一般来说这个宽度是比浏览器的可视区域大的。正确来说，视口是网页上用来显示网页那部分区域，不取决于是否在浏览器可视区域显示出来。
>
> > 因为过去网页的版心都是 980
> > 乔布斯为了能够让网页在移动端完美的显示,所以将 ios 手机视口大小定义为 980
> > 后来谷歌也将 Android 手机定义成了 980

980 问题：

- 移动端视口 980 大小后，我们可以完整看到网页大小。按我的理解，如果移动端设备屏幕的大小与视口 980 宽度一致的话，刚好可以容纳一屏网页，但是如果小于这个范围那么将不能完整看到网页内容。

提议解决方案：在小于 980 尺寸范围后，来缩小内容，以达到完整一屏容纳网页。通过将设备屏幕和视口进行适配，而不是自动缩放网页尺寸。

实际解决方案（基本适配）:

> 通过 meta 来控制视口大小（width）等于屏幕大小(device-width), 设置视口宽度等于设备宽度，初始缩放比例 initial-scale = 1.0, (1 表示不缩放)；maximum-scale 允许用户最大缩放比例，minimum-scale: 允许用户最小缩放比例； user-scalable 用户是否可以手动缩放网页尺寸。

#### 重点:

> 对于 pc 端来说，视口大小是完全等于可视区域的. 但是对于移动来说就不一定了。在移动端包括三个视口概念.

Layout viewport(浏览器默认布局视口): 移动端浏览器厂商默认定义的视口大小，通常为 980px。注意这个 layout viewport 宽度是大于浏览器可视区域的宽度的。

> 布局视口:当前浏览器的可视区域,不包括菜单栏及浏览器的 ui**不包含滚动条**等
>
> 在 PC 端上，设置 viewport 不生效,布局视口永远等于浏览器窗口的宽度。视口当前可见的部分叫做**可视视口（visual viewport）**。可视视口可能会比**布局视口**（**layout viewport** ）更小，因为当用户缩小浏览器缩放比例时，布局视口不变，而可视视口变小了**。**

```javascript
// 获取layout viewport 尺寸
document.documenntElement.clientWidth;
// 或
document.body.clientWidth;
```

Visual viewport(浏览器可视区域视口大小): 可以认为浏览器屏幕宽度

> 视觉视口:用户当前看到的区域,包含滚动条等.默认等于当前浏览器的窗口大小
>
> 用户通过缩放放大网站，**CSS 像素增大,一个 CSS 像素可以跨越更多的设备像素,我们能看到的网站区域将缩小，此时视觉视口变小**
>
> > 假设屏幕上本来需要 200 个 CSS 像素才能占满屏幕，由于放大，现在只需要 100 个 CSS 像素就能占满，所以视觉视口的宽就变成 100px。
>
> > 同理, 用户缩小网站，我们看到的网站区域将变大，此时视觉视口变大

```javascript
window.innerWidth;
```

Ideal viewport(移动设备理想 viewport): 在这种视口下的网页内容，完整适配任何分辨率的屏幕。且用户无需手动缩放查看页面内容。

> 布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时，才是理想视口。
>
> > ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对 ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。
> >
> > 比如一段 14px 大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段 14px 的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。

设备显示分辨率（逻辑分辨率):

说明：此宽度不会因为浏览器窗口变化而调整

```javascript
// 获取设备显示分辨率(理想视口ideal viewport)
window.screen.width; // 获取的尺寸不是以css像素统计，所以尽管缩放页面，此api获取的尺寸仍然不变.
```

页面缩放系数

```java
页面的缩放系数 = 理想视口宽度 / 布局视口宽度
```

**缩放:**关于度现代浏览器缩放所产生的影响

> 在现代浏览器中实现的缩放只不过是“拉伸”像素而已。即，元素的宽度没有从 128 像素改变到 256 像素；相反，实际像素的大小是原来的两倍。在形式上，元素的宽度仍然是 128 个 CSS 像素，尽管它恰好占用 256 个设备像素的空间。

分类：

Ios 下，ideal viewport 的尺寸是 320px。所有的 iphone 的 ideal viewport 宽度都是 320px，无论它的屏幕宽度是 320 还是 640，也就是说，在 iphone 中，css 中的 320px 就代表 iphone 屏幕的宽度。

Android 设备就比较复杂了，有 320px 的，有 360px 的，有 384px 的等等

获取 ideal viewport, 通过 meta viewport 的 width

```html
<meta name="viewport" content="width=device-width" />
或者 // 相对ideal viewport 百分百缩放，达到和ideal viewport
一样大小，这样就得到ideal viewport
<meta name="viewport" content="initial-scale=1" />

//
上述两种写法，在iphone或IE平台会各会存在横竖屏部分，横屏时仍然取竖屏宽度设置viewport
宽度. // 兼容写法
<meta name="viewport" content="width=device-width, initial-scale=1" />
```

获取页面相关尺寸 api 总结:

`window.innerHeight`：获取浏览器视觉视口高度（包括垂直滚动条）。

`window.outerHeight`：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。

```
window.screen.Height`：获取获屏幕取理想视口高度，这个数值是固定的，`设备的分辨率/设备像素比
```

`window.screen.availHeight`：浏览器窗口可用的高度。

`document.documentElement.clientHeight`：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。

`document.documentElement.offsetHeight`：包括内边距、滚动条、边框和外边距。

`document.documentElement.scrollHeight`：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与`clientHeight`相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。

Meta viewport 相关:

1. meta viewport 有 6 个属性(暂且把 content 中的那些东西称为一个个属性和值)，如下：

| width         | 设置**_layout viewport_** 的宽度，为一个正整数，或字符串"width-device" |
| ------------- | ---------------------------------------------------------------------- |
| initial-scale | 设置页面的初始缩放值，为一个数字，可以带小数                           |
| minimum-scale | 允许用户的最小缩放值，为一个数字，可以带小数                           |
| maximum-scale | 允许用户的最大缩放值，为一个数字，可以带小数                           |
| height        | 设置**_layout viewport_** 的高度，这个属性对我们并不重要，很少使用     |
| user-scalable | 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes 代表允许     |

这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。

此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定 css 中的 1px 代表多少物理像素

| target-densitydpi | 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 |
| ----------------- | ------------------------------------------------------------------------------------- |
|                   |                                                                                       |

特别说明的是，当 target-densitydpi=device-dpi 时， css 中的 1px 会等于物理像素中的 1px。

因为这个属性只有安卓支持，并且安卓已经决定要废弃~~target-densitydpi~~ 这个属性了，所以这个属性我们要避免进行使用 。

2. **关于缩放以及 initial-scale 的默认值**

首先我们先来讨论一下缩放的问题，前面已经提到过，缩放是相对于 ideal viewport 来缩放的，缩放值越大，当前 viewport 的宽度就会越小，反之亦然。例如在 iphone 中，ideal viewport 的宽度是 320px，如果我们设置 initial-scale=2 ，此时 viewport 的宽度会变为只有 160px 了，这也好理解，放大了一倍嘛，就是原来 1px 的东西变成 2px 了，但是 1px 变为 2px 并不是把原来的 320px 变为 640px 了，而是在实际宽度不变的情况下，1px 变得跟原来的 2px 的长度一样了，所以放大 2 倍后原来需要 320px 才能填满的宽度现在只需要 160px 就做到了。因此，我们可以得出一个公式：

```
visual viewport宽度 = ideal viewport宽度  / 当前缩放值

当前缩放值 = ideal viewport宽度  / visual viewport宽度
```

Tip:

> 这里的缩放也会导致 css1px 所代表的物理像素变化。如果放大，css1px 所代表的的物理像素增加，反之，物理像素减少。页面的上的体现就是页面元素放大，实际上元素尺寸并没有改变。只是像素差距

总结:

> ppk 把移动设备上的 viewport 分为**_layout viewport_** 、 **_visual viewport_** 和 **_ideal viewport_** 三类，其中的 ideal viewport 是最适合移动设备的 viewport，ideal viewport 的宽度等于移动设备的屏幕宽度，只要在 css 中把某一元素的宽度设为 ideal viewport 的宽度(单位用 px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为 100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对 ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。
>
> > 总之记住这个结论就行了：**在 iphone 和 ipad 上，无论你给 viewport 设的宽的是多少，如果没有指定默认的缩放值，则 iphone 和 ipad 会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说 viewport 的宽度就是屏幕的宽度)的目的。**

### 基本单位：

### 1.像素(Pixel)

> 在前端开发中视口的水平方向和垂直方向是由很多小方格组成的,一个小方格就是一个像素,
> 不会随着视口大小的变化而变化,像素是一个固定的单位(绝对单位);

### 2.百分比

> 百分比是前端开发中的一个动态(相对)单位,永远都是以当前元素的父元素作为参考进行计算 子元素高宽度都是参考父元素高宽计算的
> 子元素 padding/margin 无论是水平还是垂直方向都是参考父元素宽度计算的
> **_不能用百分比设置 border_**

### 3.em

> em 是前端开发中的一个动态单位,是一个相对于元素字体大小的单位. 例如:font-size:12px; 那么 1em=12px
> 当前元素设置了字体大小,那么就相对于当前元素的字体大小 当前元素没有设置字体大小,那么就相对于第一个设置字体大小的祖先元素的字体大小
> 如果当前元素和所有祖先元素都没有设置大小,那么就相当于浏览器默认的字体大小(1em=16px)

### 4.rem

> rem 就是 root em,和 em 一样是前端开发中的一个动态单位,rem 与 em 的区别在于 rem 是一个相对于根元素字体大小的单位,例如根元素(html)
> font-size:12px;那么 1rem=12px 除了根元素以外,其它祖先元素的字体大小不会影响 rem 大小
> 如果根元素没有设置字体大小,那么 1rem=16px;

### 5.vw(Viewport Width)和 vh(Viewport Height)

> vw 和 vh 是一个前端开发中的动态单位,是一个相对于网页视口的单位 系统会将视口的宽度和高度分为 100 份,1vw 就占视口宽度的百分之一
> vw、vh 和百分比不同的是,百分比永远都是以父元素作为参考,vw 和 vh 永远都以视口作为参考
> **_vmin:vw 和 vh 中较小那个_**
>
> **_vmax:vw 和 vh 中较大那个 使用场景:保证移动开发中屏幕旋转后尺寸不变_**

### 设备像素和 css 像素

> 设备像素：是固定的**物理单位**，是"物理屏幕"上真实存在的发光点，只有屏幕一经出厂就固定不会改变。
>
> css 像素：CSS 像素又称为**逻辑像素**，是编程世界中虚拟的东西, 我们通过代码设置的像素都是逻辑像素
>
> 例如: iPhone3G/iPhone3GS 3.5 英寸/ 逻辑像素 320*480 / 设备像素 320*480
> iPhone4/4S 3.5 英寸/ 逻辑像素 320*480 / 设备像素 640*960
> 也就是说 CSS 像素和设备像素在有的时候是不一样的
>
> > 浏览器内的一切长度都是以 CSS 像素为单位的，CSS 像素的单位是 px。

设备像素（物理像素）单位为(pt): 具体的物理量，描述是页面的单位面积的像素点数.

Css(px): 他是一个抽象单位，描述的是图像显示的最小单位。由于不同设备物理分辨率的不同，所以在 web 页面开发时，为了统一表示 1px 在不同设备屏幕，所显示的图像能一致，css 1px 所代表的的像素也就有所不同。这是就需要换算设备像素比.

例如: 在移动端适配中，是选择 iphone6 作为适配标准的，他的物理分辨率是 750 x 1334px, 而他的逻辑分辨率是 375 x 667px

历史:

> **在 PC 端，1 个 CSS 像素往往都是对应着电脑屏幕的 1 个物理像素, 所以我们无需关心 PC 端的 CSS 像素和设备像素**
>
> 在手机端，最开始其实 1 个 CSS 个像素也是对应着手机屏幕的 1 个物理像素, 但是后来一个改变世界的男人(乔布斯)改变了这一切~ 从 iPhone4 开始，苹果公司推出了所谓的 retina 视网膜屏幕。 iPhone4 的屏幕尺寸却没有变化，但是像素点却多了一倍
> 这就导致了在 1 个 CSS 个像素等于 1 个物理像素的手机上, 我们设置 1 个 CSS 像素只会占用 1 个物理像素
> 而在 1 个 CSS 个像素不等于 1 个物理像素的手机上, 我们设置 1 个 CSS 像素就会占用 2 个物理像素
> 所以仔细观察你会发现同样是 1 像素但是在 retina 视网膜屏幕的手机上会粗一些
>
> 安卓设备根据屏幕像素密度可分为 ldpi、mdpi、hdpi、xhdpi 等不同的等级，分辨率也是五花八门，安卓设备上的一个 css 像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。

理想解决方案(设备像素和 css 像素不一致):

> 如果设备像素和 css 逻辑像素一致，那么无需做任何转换计算处理。比如设备像素是 css 像素的两倍，三倍设置更多，那么乘以相应的设备像素比列即可，但是每次都需要计算转换处理。

实际解决方案: 获取设备像素比 DPR(Device Pixel Ratio)

```javascript
DPR = 设备像素 / CSS像素
eg:(这里的例子，只是在宽度上计算了设备像素比；高度上一般不会计算)
iPhone3GS :  320 / 320 = 1 iPhone4S: 640 / 320 = 2 iPhone678:   750 / 375 = 2 iPhoneX: 1125 / 375 = 3
```

引起 css 像素相对设备像素变化因素:

1. 移动设备的不同
2. 移动设备用户的缩放

Tips:

> window 对象有一个 devicePixelRatio 属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css 中的 px 就可以看做是设备的独立像素，所以通过 devicePixelRatio，我们可以知道该设备上一个 css 像素代表多少个物理像素

```javascript
// js获取设备像素比
window.devicePixelRatio;
```

#### 总结

> 上述整个适配讲述，都是围绕 px 来展开的。pc 端由于设备像素比是 1, 所以如果使用 px 作为设计尺寸，是不会有任何误差的。

### 移动端适配方案

通过判断 PC/Android(ios)实现 pc 端/移动端界面自动跳转

实现步骤: 1.默认打开 PC 端界面 2.在 PC 端界面中通过 BOM 拿到当前浏览器信息 3.通过正则判断当前浏览器是否是移动端浏览器 4.通过 BOM 的 location 对象实现跳转到移动端界面

```javascript
// 设备类型判断
function isPc() {
  let userAgentInfo = navigator.userAgent;
  if (/iphone/i.test(userAgentInfo)) {
    // IOS
    return false;
  } else if (/android/i.test(userAgentInfo)) {
    // Android
    return false;
  } else {
    // PC
    return true;
  }
}

// 处理跳转
if (!isPc()) {
  location.href = "https://m.baidu.com";
} else {
  location.href = "https://www.baidu.com";
}
```

适配方案:

1. 媒体查询: @media(Media Query):为不同尺寸的屏幕设定不同的 CSS 样式

常用参数:

<img src="https://img-blog.csdnimg.cn/20201201115650409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RlYXRoejE1,size_16,color_FFFFFF,t_70#pic_center">

2. 媒体查询结合 rem

场景：

1. 当下在企业开发中设计师提供给我们的移动端设计图片是 750*xxx 的或者 1125*xxx 的（这里的尺寸是物理尺寸 px)
   所以我们需要对设计师提供的图片进行等比缩放, 这样才能 1:1 还原设计图片

2. 等比缩放

   > 分配的份数约定为 7.5 份

   (1)设计图（这里说的设计图指的是整个设计图）尺寸等分为指定份数,求出每一份大小。

   例如： 750 的设计图等分为 7.5, 那么每一份就是 100px

   (2) 将目标屏幕(设备屏幕)也等分为指定份数,求出每一份的大小

   例如：375 大小的设备等分 7.5，那么每一份就是 50

   (3)等比缩放： （设计图上的元素）原始元素尺寸 / 原始图片每一份大小 \* 目标屏幕每一份大小 = 等比缩放后的尺寸

   > 例如: 设计图片上有一个 150*150 的图片, 我想等比缩放显示到 375 屏幕上
   > 那么: 150 / 100 \* 50 = 1.5*50 = 75px

3. 实际开发中，引用此缩放公式

   > 目标屏幕每一份的大小就是 html 的 font-size: 50px
   > 使用时只需要用 “原始元素尺寸 / 原始图片每一份大小 rem” 即可
   > (150 / 100 = 1.5) == 1.5rem
   > (1rem = 50px) == (1.5rem === 1.5\*50 = 75px)

这里使用 rem 相对单位，等比缩放设计图元素.

3. Js + rem

rem 适配相关:

(1): 基准值计算, 默认 1rem = 16px (html fontsize)这个 16px 就是 rem 基准值(基本数值,最小换算单位).

(2): rem 数值计算和构建: rem 数值计算: 元素视觉稿大小 / 基准值 = x rem

(3): rem 结合 scss 等 css 预处理

总结：

> 上面的方式，仅仅将设计图按比例设置到页面，但是关于设备的像素和 css 像素的差距，未处理。

flex 适配

> 固定 viewport, 不允许用户手动缩放视口

**css 像素和设备像素区别**

您需要了解的第一个概念是 CSS 像素，以及与设备像素的区别。

设备像素是我们直觉上认为“正确”的像素。这些像素给出了您正在使用的任何设备的形式分辨率，并且（通常）可以从屏幕上读取。宽度/高度。

如果你给一个特定的元素一个宽度：128px，你的显示器是 1024px 宽，并且你最大化了你的浏览器屏幕，那么这个元素会在你的显示器上显示八次（大致上，现在让我们忽略一些棘手的部分）。

但是，如果用户缩放，此计算将更改。如果用户放大到 200%，那么宽度为 128px 的元素在其 1024px 宽的显示器上只能显示四次。

在现代浏览器中实现的缩放只不过是“拉伸”像素而已。即，元素的宽度没有从 128 像素改变到 256 像素；相反，实际像素的大小是原来的两倍。在形式上，元素的宽度仍然是 128 个 CSS 像素，尽管它恰好占用 256 个设备像素的空间。

换句话说，**缩放到 200%会使一个 CSS 像素增长到一个设备像素大小的四倍。**（两倍宽度，两倍高度，总产量为四倍）。

一些图片将阐明这个概念。这里是四个像素的 100%缩放级别。这里没什么可看的；CSS 像素与设备像素完全重叠。

<img src="https://www.quirksmode.org/mobile/pix/viewport/csspixels_100.gif" />

现在让我们缩小。CSS 像素开始缩小，这意味着一个设备像素现在与几个 CSS 像素重叠。

<img src="https://www.quirksmode.org/mobile/pix/viewport/csspixels_out.gif" />

如果放大，情况正好相反。CSS 像素开始增长，现在一个 CSS 像素与几个设备像素重叠。

<img src="https://www.quirksmode.org/mobile/pix/viewport/csspixels_in.gif"/>

这里的要点是，您只对 CSS 像素感兴趣。正是这些像素决定了样式表的渲染方式。设备像素对您几乎完全没有用处。不适用于用户；用户将放大或缩小页面，直到他能够轻松阅读。但是，缩放级别对您来说并不重要。浏览器将自动确保您的 CSS 布局被拉伸或挤压。

**100% 缩放比**

我首先假设缩放级别为 100%。是时候更严格地定义一下了：

> 在缩放级别 100%时，一个 CSS 像素正好等于一个设备像素。

在接下来的解释中，100%缩放的概念非常有用，但是在日常工作中，你不应该过分担心它。在桌面上，你通常会以 100%的缩放来测试你的站点，但即使用户放大或缩小 CSS 像素的魔力，也会确保你的布局保持相同的比例。

**屏幕尺寸**

让我们看一下一些实际测量值。我们将从 screen.width 和 screen.height 开始。它们包含用户屏幕的总宽度和高度。这些尺寸是以设备像素为单位测量的，因为它们永远不会改变：它们是显示器的功能，而不是浏览器的功能。

<img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_screen.jpg" />

基本上没什么。用户的监视器大小对我们来说并不重要，除非您想在 web 统计数据库中使用它。

**浏览器窗口大小**

<img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_inner.jpg" />

显然，窗口的内部宽度是以 CSS 像素为单位测量的。您需要知道可以在浏览器窗口中压缩多少布局，并且随着用户放大，压缩量会减少。因此，如果用户放大，则窗口中的可用空间会减少，window.innerWidth/Height 会通过减少来反映这一点。

（这里的例外是 Opera，其中 window.innerWidth/Height 在用户放大时不会减小：它们是以设备像素为单位测量的。这在桌面上很烦人，但在移动设备上却是致命的，我们将在后面看到。）

注意，测量的宽度和高度包括滚动条。它们也被认为是内窗的一部分。(这主要是由于历史原因。)

**滚动偏移量**

window.pageXOffset 和 window.pageYOffset 包含文档的水平和垂直滚动偏移量。因此，您可以了解用户已滚动了多少。

<img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_page.jpg" />

这些属性也是用 CSS 像素来度量的。您想知道文档已经向上滚动了多少，无论它处于何种缩放状态。

理论上，如果用户向上滚动然后放大，window.pageX/YOffset 将发生变化。然而，当用户缩放时，浏览器试图通过在可见页面的顶部保留相同的元素来保持网页的一致性。这并不总是完美地工作，但这意味着在实践中 window.pageX/YOffset 并没有真正改变：已从窗口中滚出的 CSS 像素数（大致）保持不变。

<img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_page_zoomed.jpg" />

![image-20210927153133798](/Users/ousan/Library/Application Support/typora-user-images/image-20210927153133798.png)

![image-20210927153237658](/Users/ousan/Library/Application Support/typora-user-images/image-20210927153237658.png)

![image-20210927153327099](/Users/ousan/Library/Application Support/typora-user-images/image-20210927153327099.png)

实现总结：

缩小页面，页面元素缩小，成像比较小。

原理解释： 缩小的时候，一个设备像素对应几个 css 像素. 总结为，现在的 css 中，px 描述的图像元素成像只需要对应少量的设备像素点即可。

所以在设备上，看到的图像元素是显小的。

放大页面，页面元素放大，成像更大。

原理解释： 放大的时候，一个 css 像素对应好几个设备像素。总结为，现在 css 中，1px 描述的图像需要更多设备像素，所以在设备上，看到的最终图像是显大的。

css 像素和设备像素（物理像素再度释意）:

css 所代表的的像素相对设备像素(device pixel):

css 像素相对性:

在`CSS`规范中，长度单位可以分为两类，绝对(`absolute`)单位以及相对(`relative`)单位。`px`是一个**相对单位**，相对的是设备像素(`device pixel`)。

在同样一个设备上，每 1 个 CSS 像素所代表的物理像素是可以变化的(**即 CSS 像素的第一方面的相对性**);

在不同的设备之间，每 1 个 CSS 像素所代表的物理像素是可以变化的(**即 CSS 像素的第二方面的相对性**);

关于 pixel: 首先它不是一个物理量，而是抽象的量而存在。他是物体成像基本采样，换句话说是图像显示的基本单元.

> 不同的设备，图像基本采样单元(像素概念)是不同的，显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为`ppi`和`dpi`：

ppi: 像素密度，每英寸多少像素数，放到显示器上说的是**每英寸多少物理像素**及显示器设备的 **点距**。

dpi: 每英寸多少点. 注意这里说的点，说的采样单元是 ** 墨点**

> 当描述显示器设备时，dpi 和 dpi 是一个概念

css 像素真正含义:

> 不同设备物理像素不一样，不同设备显示一致，web 开发时，在 css 中，使用 css 像素和物理像素，参照“参考像素”进行统一换算，使得单位 css 像素和单位物理像素两者表现一致。

> **由于不同的物理设备的物理像素的大小是不一样的，所以`css`认为浏览器应该对`css`中的像素进行调节，使得浏览器中 1css 像素的大小在不同物理设备上看上去大小总是差不多 ，目的是为了保证阅读体验一致** **。为了达到这一点浏览器可以直接按照设备的**物理像素\*\*大小进行换算，而`css`规范中使用 "参考像素" 来进行换算。

参考像素：本质是视角单位，**(1/96)in / (28in \* 2 \* PI / 360deg) = 0.0213 度。**

由于`css`像素是一个**视角单位**，所以在真正实现时，为了方便基本都是根据**设备像素**换算的。浏览器根据硬件设备能够直接获取`css`像素

**1 参考像素**即为从一臂之遥看解析度为`96DPI`的设备输出（即 1 英寸 96 点）时，1 点（即 1/96 英寸）的视角。它并不是 1/96 英寸长度，而是从一臂之遥的距离处看解析度为`96DPI`的设备输出一单位（即 1/96 英寸）时视线与水平线的夹角。通常认为常人臂长为 28 英寸，所以它的视角是:
**(1/96)in / (28in \* 2 \* PI / 360deg) = 0.0213 度。**

设备像素(物理像素): 单位 pt

> **设备像素（物理像素）**，顾名思义，显示屏是由一个个**物理像素**点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的**物理像素点**就固定不变了，单位**pt**。
>
> 设备的真实分辨率 屏幕有多少个像素点 就是多少分辨率。
>
> > 以 iphone6 为例 物理分辨率为 750\*1334,也就是显示屏内部 led 灯的个数

**`pt`在`css`单位中属于真正的绝对单位，`1pt = 1/72(inch)`,`inch`及英寸，而 1 英寸等于 2.54 厘米。**

不同的设备，其图像基本单位是不同的，比如显示器的点距，可以认为是显示器的**物理像素**。现在的液晶显示器的点距一般在`0.25mm`到`0.29mm`之间。而打印机的墨点，也可以认为是打印机的物理像素，`300DPI`就是`0.085mm`，`600DPI`就是`0.042mm`。**这句话的表达的意思是，不同设备的采样单元（pxiel），也就是不同设备的物理像素不同，而设备的物理像素，是以物理像素点的间距来描述的。**

注意，我们通常所说的**显示器分辨率**，其实是指**桌面设定的分辨率**，而不是显示器的**物理分辨率**。只不过现在液晶显示器成为主流，由于液晶的显示原理与`CRT`不同，**只有在桌面分辨率与物理分辨率一致的情况下，显示效果最佳**，所以现在我们的桌面分辨率几乎总是与显示器的物理分辨率一致了。比如 iphone6 的物理分辨率是，750 x1334px, 而他的显示分辨率（理想分辨率）是 375 x 667px;

TIp:

> 小知识:屏幕普遍采用 RGB 色域(红、绿、蓝三个子像素构成),而印刷行业普遍使用 CMYK 色域(青、品红、黄和黑)

设备像素(DP)和 css 像素关系:

> 获得设备像素比（dpr）后，便可得知设备像素与 CSS 像素之间的比例。当这个比率为 1:1 时，使用 1 个设备像素显示 1 个 CSS 像素。当这个比率为 2:1 时，使用 4 个设备像素显示 1 个 CSS 像素，当这个比率为 3:1 时，使用 9（3\*3）个设备像素显示 1 个 CSS 像素。

设备独立像素(Device independent Pixel):

设备独立像素，也称为逻辑像素，简称`dip`。
根据上述设备像素与`CSS`像素之间的关系、及`DPR`的官方定义，我们可以推断出：

> **CSS 像素 =设备独立像素 = 逻辑像素**

> 为什么是“每四个一组”？而且要让这四个一组来显示“原来屏幕的一个像素”？这大概就是 Retina 显示技术的一种表现吧。而这“每四个一组”的“大像素”，可以被称作“设备独立像素”，`device independent pixel` ，或者 `density-independentpixel` ，它可以是系统中的一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统转换为物理像素。

“设备独立像素”也有人称为“CSS 像素”，一种形象的说法，更倾向于表明与 `CSS` 中尺寸的对应。

设备独立像素与物理像素的对应关系，可以这样看:

> 四个一组的设备像素对应一个虚拟像素（设备独立像素）

类似的每四个一组的对应关系，也许正是 `Retina` 显示技术所做的

> 一种单位(web 开发，采用 px 作为逻辑像素单位，来对应设备像素)来告诉不同分辨率的手机，它们在界面上显示元素的大小是多少 即设备几个像素(物理像素)当成一个像素(逻辑像素)使用

设备像素比(DPR):

> **设备像素比（dpr** 描述的是未缩放状态下，`物理像素`和`CSS像素`的初始比例关系，计算方法如下图。
>
> > css 中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css 中的 1px 所代表的设备物理像素是不同的,1px 并不是绝对的,它只代表了当前设备像素的最小单位.
> >
> > 在 pc 端 1px 等于一个设备的物理像素,但是移动设备的屏幕像素密度越来越高 ,iphone6 上一个 css 像素是等于两个物理像素,通过**dpr**，我们可以知道该设备上一个 css 像素代表多少个物理像素

**设备像素比(dpr)** 是指在移动开发中 1 个 css 像素占用多少设备像素，如 2 代表 1 个 css 像素用 2x2 个设备像素来绘制。

**设备像素比(dpr)**，公式为`1px = (dpr)^2 * 1dp`，可以理解为 1px 由多少个设备像素组成；

(PPI)像素密度:

> **每英寸像素取值**，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。或者是单位面积的物理像素及显示器点距。`PPI`可以用于描述屏幕的清晰度以及一张图片的质量,`PPI`越高，屏幕越清晰。

ppi 的计算：

a = v(r^2+h^2), v 开根号， r 表示横向分辨率大小，h 表示垂直分辨率大小

ppi = a / 主屏尺寸

> **我们知道，ppi 越高，每英寸像素点越多，图像越清晰；我们可以类比物体的密度，密度越大，单位体积的质量就越大，ppi 越高，单位面积的像素越多。**

ppi 和 dpr 关系：

**设备像素比与 ppi 相关，一般是 ppi/160 的整数倍：**

### 倍率和逻辑像素

用 iPhone 3gs 和 4s 来举例。假设有个邮件列表界面，我们不妨按照 PC 端网页设计的思维来想象。3gs 上大概只能显示 4-5 行，4s 就能显示 9-10 行，而且每行会变得特别宽。但两款手机其实是一样大的。如果照这种方式显示，3gs 上刚刚好的效果，在 4s 上就会小到根本看不清字。

在现实中，这两者效果却是一样的。这是因为 Retina 屏幕把 2x2 个像素当 1 个像素使用。比如原本 44 像素高的顶部导航栏，在`Retina`屏上用了 88 个像素的高度来显示。导致界面元素都变成 2 倍大小，反而和 3gs 效果一样了。画质却更清晰。

在以前，iOS 应用的资源图片中，同一张图通常有两个尺寸。你会看到文件名有的带[@2x](https://github.com/2x)字样，有的不带。其中不带[@2x](https://github.com/2x)的用在普通屏上，带[@2x](https://github.com/2x)的用在`Retina`屏上。只要图片准备好，iOS 会自己判断用哪张，`Android`道理也一样。

由此可以看出，苹果以普通屏为基准，给`Retin`a 屏定义了一个 2 倍的倍率（`iPhone 6plus`除外，它达到了 3 倍）。**实际像素除以倍率，就得到逻辑像素尺寸。只要两个屏幕逻辑像素相同，它们的显示效果就是相同的。**

**retina 屏幕**

这是一种显示技术，可以将**把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度**，这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。

最先使用`retina`屏幕是 iphone 4，屏幕分辨率为 960 \* 640(326ppi)

两代 iPhone 的物理尺寸（屏幕宽高有多少英寸）是一样的，从上图可以看出，iphone 4 的显示效果要明显好于 iphone 3GS，虽然 iPhone 4 分辨率提高了，但它不同于普通的电脑显示器那样为了显示更多的内容，而是提升显示相同内容时的画面精细程度。**这种提升方式是靠提升单位面积屏幕的像素数量，即像素密度来提升分辨率，这样做的主要目的是为了提高屏幕显示画面的精细程度**。以第三代 `MacBook Pro with Retina Display`为例， 工作时显卡渲染出的 2880x1880 个像素每四个一组，输出原来屏幕的一个像素显示的大小区域内的图像。这样一来，用户所看到的图标与文字的大小与原来的 1440x900 分辨率显示屏相同，但精细度是原来的 4 倍。

注意：在桌面显示器中，我们调整了显示分辨率，比如从 800 _ 600 调整到 1024 _ 768 时，屏幕的文字图标会变小，显示的内容更多了。但 `Retina` 显示方式不会产生这样的问题，或者说， **Retina 显示技术解决的是显示画面精细程度的问题，而不是解决显示内容容量的问题。**理解这句话，表达的是，屏幕变大了，分辨率提高了，单位面积的 ppi 变多了，但是图像的呈现仍然是以 1：1 的方式，只是说显示器内，容纳的内容变多了，但是不能改变显示的效果；而 retina 屏不一样，是在相同设备屏幕尺寸下，提高单位设备像素和逻辑像素的比，来提高图像显示效果。

### 分辨率，像素和屏幕尺寸

`PPI` 说的是像素密度，而分辨率说的是块屏幕的像素尺寸，譬如说 1334\*750 就是 iPhone（6~7）的分辨率，说 iPhone（6~7）的分辨率是 326 是错误的表述，326 是它的像素密度，单位是 `PPI`。

询问别人一粒像素有多大是一个非常鸡贼的问题（小心面试遇到这样的题），虽然我们说像素是构成屏幕的发光的点，是物理的，但是像素在脱离了屏幕尺寸之后是没有大小可言的，你可以将 1920 \* 1080 颗像素放到一台 40 寸的小米电视机里面，也可以将同样多的像素全部塞到一台 5.5 寸的 iPhone7 Plus 手机里面去，那么对于 40 寸的电视而言，每个像素颗粒当然会大于 5.5 寸的手机的像素。

所以光看屏幕的分辨率对于设计师来说是不具备多少实际意义的，通过分辨率计算得出的像素密度（PPI）才是设计师要关心的问题，我们通过屏幕分辨率和屏幕尺寸就能计算出屏幕的像素密度的。

再次使用 iPhone（6~7）作为例子。我们知道该屏幕的横向物理尺寸为 2.3 英寸 ，且横向具有 750 颗像素，根据下面的公式，我们能够算出 iPhone（6~7）的屏幕是 326 PPI，意为每寸存在 326 颗像素。

其实不论我们怎么除，计算得出来的`像素密度（PPI）`都会是这个数，宽存在像素除以宽物理长度，高存在像素除以高物理长度，得数都接近于 326。**理解这句话，ppi 的计算可以根据分辨率除以设备主屏单边的尺寸，近似得到。**

屏幕分辨率:

> 指屏幕横向和纵向的像素点数，或者块屏幕的像素尺寸，单位 px。 相同大小的屏幕 分辨率越低,单位像素尺寸越大,分辨率越高,单位像素尺寸越小

图像分辨率 :

> 指图片含有的像素数 , 表示图片分别在垂直和水平上所具有的像素点数。同一尺寸的图片，分辨率越高，图片越清晰。
