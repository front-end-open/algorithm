---
sidebar: auto
---

## 栈(stack)

### 栈的定义

> 定义，限定在表尾进行删除和插入操作的线性表.
>
> > 栈顶： 把允许删除和插入数据的一端
>
> > 栈底：相对于栈顶的另一端
>
> > 进出栈原则： 后进先出（LIFO）

::: tip
栈内元素的线性关系，栈也被描述为线性表.

> 栈的插入操作被称为，入栈
>
> 栈的删除操作被称为，出栈

:::

### 进出栈的变化形式

> 在不是所有元素都进出栈的情况，栈内元素进出栈的顺序是可以变化的，只要保证栈顶元素出栈即可.

```md
// 比如使用 123，三个元素，依次进栈，来描述不同的进出栈情况
// 顺序全部进栈

1. 1,2,3, 则，出栈的次序为， 1，2，3
2. 3，2，1，则，出栈的次序为，3，2，1

// 部分元素先完成进出栈的情况

3. 1, 进，出； 则，2， 3 依次进栈，最终出栈次序为，1，3，2
4. 1，进，出， 2，进，出，则，最终出栈次序为，2，1，3
5. 1，进，出，2，进，3，进。则，最终出战次序为，2，3，1
```

### 栈抽线数据类型

```md
ADT 栈(stack)

Data
同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系

Operation
init: 初始化操作，简历一个空栈 S
destroyStack: 销毁栈
ClearStack: 清空栈
stackEmpty: 栈是否是空栈
getTop: 获取栈顶元素
Push: 插入元素
Pop: 删除栈顶元素
stackLength: 返回栈内元素个数
```

### 栈存存储结构

> 链式存储结构和顺序存储结构

#### 栈顺序存储结构

实现方式:

1. 数组： 为什么选择数组，那是因为数组天然就是线性表，适合用来表示栈这种数组结构。
2. 对象：选择对象，选择对象的原因是，对象的 key-map 形式，完全也可以作为栈的线性描述。

### 两栈的共享空间

> 当两个栈的内存空间，各自存在增加和压缩的相反趋势的增长情况时，就可以使用一个数组来共享两个栈的存储空间

使用时机:

1. 两个栈的数据元素的类型一致
2. 两个栈的存储空间存在相反增长趋势，即一个栈在增加元素，相反另一栈的内存空间就会被压缩。

设计要点:

:::tip

切入点： 两栈仍然使用 Stack 类的数据结构设计，在数组中，共享栈空间时，使用额外变量表示两栈在数组中的栈底表示。

:::

- 用一个数组来存储两个栈的存储空间，预先需要声明两个栈，如何确定两个栈的栈底在数组的位置？
- 除此之外，还需要考虑两个栈空间的大小，在数组中？
- 数组空间大小与两栈的关系?

### 栈的链式存储空间

> 使用单链表来实现，栈数据结构。而且这种结构不需要考虑栈空间的大小。
> 注意：栈是通过栈顶来插入和删除元素，所有的后续操作都是通过栈顶来继续。

**基本操作**

1. （push）入栈
   原理：每次入栈都是通过将新元素复制给栈顶指针，而后再将栈顶指针的引用复制给头指针。每次将新元素复制给栈顶指针`top`这一步的目的是，因为入栈操作是通过栈顶指针来继续的，所以每次栈顶指针`top`,都应该是记录的最新元素。

2. pop 出栈
   原理：找到栈顶的元素的前一位元素；保存栈顶元素的引用到临时变量`p`, 将栈顶的`p`示范。并将栈顶前一位元素，作为新的栈顶元素复制给，栈顶指针`top`。

**顺序栈特点**

1. 时间复杂度 O(1)
2. 空间复杂度开销大，因为需要预先预留内存空间，会造成内存浪费。
3. 但由于在存储定位时，是非常方便的。

**链栈特点**

1. 时间复杂度 O(1)
2. 无需声明预留内存空间
3. 存储定位比较复杂，因为每个数据元素，都存在指针的引用，这也就增加了内存开销。

**两种数据结构的选择**

> 如果在使用过程中，元素的变化不可预料则选择，链栈；反之，如果元素变化范围消，可预先确定，则选择顺序栈。

**栈的应用**

1. 阶乘
2. 递归求解斐波拉契数列
